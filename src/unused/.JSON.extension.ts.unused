/* eslint-disable @typescript-eslint/no-unnecessary-condition --
* Conditional assignment for `Array.prototype` props (`??=`) is intentional and context-aware:
* it acts as a runtime polyfill or extension, only defining the method if it doesn't already exist.
* Although the method may appear always present in type definitions,
* the actual environment might lack it (e.g. ES2022 targets).
*/
/* eslint-disable @typescript-eslint/no-explicit-any --
* Following type definitions of JSON.
*/
/* eslint-disable @typescript-eslint/naming-convention --
* Naming inner class property
*/
import type { Maybe } from "./types.js"

/* eslint-disable-next-line @typescript-eslint/no-unsafe-function-type --
* Type provided by internal constructors
*/
type AnyCtor = (new (...args: Array<any>) => any) | Function
const JSON_minimify_Tag = {
	"JSON.minimify.Tag": class extends String {
		/**
		 * Reference to constructor of overflown property.
		 */
		refCtor: AnyCtor

		constructor(value: string, refCtor: AnyCtor) {
			super(value)

			this.refCtor = refCtor
		}
	},
}

type MinimifyOptions = {

	/**
	 * Custom replacer function, same as in `JSON.stringify`.
	 *
	 * @see {@link JSON.stringify}
	 */
	replacer?: (key: string, value: any) => any,

	/**
	 * Indentation for pretty-printing.
	 *
	 * @see {@link JSON.stringify}
	 */
	space?: string | number,

	/**
	 * Maximum depth to traverse before replacing with a tagged representation.
	 *
	 * Default: Infinity (undefined).
	 */
	maxDepth?: number,

	/**
	 * If true, returns a Promise that resolves with the result.
	 * If a number, sets a timeout in milliseconds - the promise will reject
	 * if serialization exceeds this time.
	 */
	async?: true | number,
}

interface MinimifyFn {

	/**
	 * Serializes a JavaScript value into a JSON string, with depth control
	 * and optional timeout-based asynchronous execution.
	 *
	 * @param value The value to serialize.
	 * @param options Optional configuration object.
	 *
	 * @returns A JSON string or a Promise that resolves to one.
	 * @throws Error in Promise if timeout is exceeded in async mode.
	 */
	(value: any, options?: MinimifyOptions): string | Promise<string>,

	/**
	 * Tagged representation used when an object exceeds maxDepth or is cyclic.
	 * Extends String to allow easy detection in replacer functions.
	 *
	 * @example
	 * new JSON.minimify.Tag("[object MyClass]")
	 */
	Tag: typeof JSON_minimify_Tag["JSON.minimify.Tag"],

}

declare global {
	interface JSON {

		/**
		 * Serializes a JavaScript value into a JSON string, with depth control
		 * and optional timeout-based asynchronous execution.
		 *
		 * @param value The value to serialize.
		 * @param options Optional configuration object.
		 *
		 * @returns A JSON string or a Promise that resolves to one.
		 * @throws Error in Promise if timeout is exceeded in async mode,
		 * or when JSON.stringify errors due to cyclic references in unbound serialization,
		 * or BigInts etc..
		 */
		minimify: MinimifyFn,
	}
}

// const minimifyInternal = function minimifyInternal(
// 	value: unknown,
// 	options: MinimifyOptions,
// 	depth: number,
// ): unknown {
// 	if (value === null || typeof value !== "object") { return value }
// 	if (value === undefined) { return undefined }

// 	const ctor = value.constructor ?? Object
// 	const ctorName = ctor.name || "Object"

// 	if (options.maxDepth !== undefined && depth >= options.maxDepth) {
// 		return new JSON_minimify_Tag(`[object ${ctorName}]`, ctor)
// 	}

// 	if (Array.isArray(value)) {
// 		return value.map((item) => minimifyInternal(item, options, depth + 1))
// 	}

// 	const result: Record<string, unknown> = {}
// 	// eslint-disable-next-line guard-for-in -- we want to copy prototype too
// 	for (const key in value) {
// 		const k = key as keyof typeof value
// 		result[key] = minimifyInternal(value[k], options, depth + 1)
// 	}
// 	return result
// }

type ReplacerFn = (this: unknown, key: string, value: unknown) => unknown

class PruningReplacer {
	userReplacer: ReplacerFn
	maxDepth: number
	branchStack: Array<{
		path: Array<string>,
		node: unknown,
	}>
	replacer: ReplacerFn

	constructor(
		userReplacer: Maybe<ReplacerFn>,
		maxDepth: Maybe<number>,
	) {
		this.userReplacer = userReplacer ?? ((_, v) => v)
		this.maxDepth = maxDepth ?? Infinity
		this.branchStack = []

		const self = this
		this.replacer = function PruningReplacer_replacer(
			this: unknown,
			key: string,
			value: unknown,
		) {
			if (key === "" && self.branchStack.length === 0) {
				self.branchStack.push({
					path: [],
					node: value,
				})
			}
		}
	}
}

JSON.minimify ??= Object.assign(function minimify(
	value: any,
	options: MinimifyOptions = {},
): string | Promise<string> {
	const { replacer, space, async, maxDepth } = options

	const s = {
		"JSON.minimify.serialize"() {
			const pruner = new PruningReplacer(replacer, maxDepth)
			return JSON.stringify(value, pruner.replacer, space)
		},
	}
	if (async) {
		if (typeof async !== "number") {
			return new Promise((res) => { res(s["JSON.minimify.serialize"]()) })
		}

		return Promise.race([
			new Promise<string>((res, rej) => {
				queueMicrotask(() => {
					try {
						res(s["JSON.minimify.serialize"]())
					} catch(e) {
						rej(e)
					}
				})
			}),
			new Promise<string>((_, rej) => void setTimeout(() => {
				rej(new Error(`Serialization exceeded timeout ${async}ms.`))
			}, async)),
		])
	}

	return s["JSON.minimify.serialize"]()
}, {
	Tag: JSON_minimify_Tag["JSON.minimify.Tag"],
})
